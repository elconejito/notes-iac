- hosts: all
  become: yes
  vars:
    stack_path: "/opt/notes-stack"
    local_data: "/opt/notes-stack/data"
    mount_path: "/mnt/notes_data"

  tasks:
    # 1. PREREQUISITES
    - name: Install system dependencies
      apt:
        name: [rsync, apt-transport-https, ca-certificates, curl, software-properties-common, gnupg]
        state: present
        update_cache: yes

    # 2. INSTALL DOCKER & DOCKER-COMPOSE
    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker Repository
      apt_repository:
        repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable
        state: present

    - name: Install Docker Engine
      apt:
        name: [docker-ce, docker-ce-cli, containerd.io, docker-compose-plugin]
        state: present
        update_cache: yes

    - name: Ensure Docker service is started
      service:
        name: docker
        state: started
        enabled: yes

    # Create a symbolic link so 'docker-compose' command works (the plugin uses 'docker compose')
    - name: Create docker-compose alias
      file:
        src: /usr/bin/docker
        dest: /usr/local/bin/docker-compose
        state: link
      ignore_errors: yes

    # 2.5. SETUP SWAP FILE (to prevent OOM errors on low-resource droplets)
    - name: Check if swap already exists
      command: swapon --show
      register: swap_check
      changed_when: false
      failed_when: false

    - name: Create swap file (2GB for 1GB RAM droplet)
      command: fallocate -l 2G /swapfile
      args:
        creates: /swapfile
      when: swap_check.rc != 0 or swap_check.stdout == ""

    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
        owner: root
        group: root
      when: swap_check.rc != 0 or swap_check.stdout == ""

    - name: Format swap file
      command: mkswap /swapfile
      args:
        creates: /swapfile
      when: swap_check.rc != 0 or swap_check.stdout == ""

    - name: Enable swap file
      command: swapon /swapfile
      when: swap_check.rc != 0 or swap_check.stdout == ""

    - name: Make swap permanent in /etc/fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        regexp: '^/swapfile'
        state: present
      when: swap_check.rc != 0 or swap_check.stdout == ""

    - name: Set swappiness to 10 (reduce swap usage, prefer RAM)
      sysctl:
        name: vm.swappiness
        value: '10'
        state: present
        sysctl_set: yes
        reload: yes

    - name: Set swap pressure to 50 (balance between cache and swap)
      sysctl:
        name: vm.vfs_cache_pressure
        value: '50'
        state: present
        sysctl_set: yes
        reload: yes

    # 3. OPTIONAL BLOCK STORAGE SETUP
    - name: Handle Block Storage Mounting
      block:
        - name: Format and Mount Volume
          mount:
            path: "{{ mount_path }}"
            src: /dev/disk/by-id/scsi-0DO_Volume_notes-data-vol
            fstype: ext4
            state: mounted
        - name: Ensure permissions on mount
          file: path={{ mount_path }} state=directory owner=root group=root mode=0755
      when: enable_block_storage | bool

    # 4. DATA MIGRATION LOGIC
    - name: Check if migration is needed
      stat: path={{ local_data }}
      register: local_dir_check

    - name: Check if Block Storage is empty
      find: paths="{{ mount_path }}"
      register: mount_contents
      when: enable_block_storage | bool

    - name: Perform Migration to Block Storage
      block:
        - name: Stop stack for safe migration
          shell: "docker compose -f {{ stack_path }}/docker-compose.yml stop"
          ignore_errors: yes

        - name: Sync data from Local to Block Storage
          command: "rsync -avz {{ local_data }}/ {{ mount_path }}/"
          
        - name: Rename old local data to prevent accidental use
          command: "mv {{ local_data }} {{ local_data }}_backup_{{ ansible_date_time.date }}"
      when: 
        - enable_block_storage | bool
        - local_dir_check.stat.exists 
        - mount_contents.matched == 0

    # 5. DEPLOY CONFIGURATIONS
    - name: Create required subdirectories
      file:
        path: "{{ item }}"
        state: directory
      loop:
        - "{{ stack_path }}"
        - "{{ stack_path }}/nginx"
        - "{{ (enable_block_storage | bool) | ternary(mount_path + '/joplin-db', local_data + '/joplin-db') }}"

    - name: Create optimized PostgreSQL configuration for low-resource droplet
      copy:
        dest: "{{ stack_path }}/postgresql.conf"
        content: |
          # PostgreSQL configuration optimized for 1GB RAM droplet with few concurrent users
          # Memory settings (total ~200MB for PostgreSQL)
          shared_buffers = 64MB
          effective_cache_size = 192MB
          maintenance_work_mem = 32MB
          work_mem = 4MB
          
          # Connection settings (few users expected)
          max_connections = 20
          
          # Performance settings
          checkpoint_completion_target = 0.9
          wal_buffers = 16MB
          default_statistics_target = 100
          
          # Logging (minimal for low-resource)
          logging_collector = off
          log_statement = 'none'
          log_duration = off
          log_line_prefix = ''
        mode: '0644'

    - name: Deploy Docker Compose file
      template:
        src: templates/docker-compose.yml.j2
        dest: "{{ stack_path }}/docker-compose.yml"
      register: compose_updated

    - name: Deploy Docker Compose and Nginx Templates
      template:
        src: "templates/{{ item }}.j2"
        dest: "{{ stack_path }}/nginx/{{ item }}"
      loop:
        - joplin.conf
      register: config_updated

    # 6. START STACK
    - name: Start/Restart Docker Stack
      shell: "docker compose -f {{ stack_path }}/docker-compose.yml up -d --force-recreate"
      when: config_updated.changed or compose_updated.changed
